.. _config:

Configuration
=============

All configurations take place in your project's conf.py file.


.. contents::


Activation
----------

Add **sphinxcontrib.needs** to your extensions::

    extensions = ["sphinxcontrib.needs",]

Options
-------

All options starts with the prefix **needs_** for this extension.

needs_include_needs
~~~~~~~~~~~~~~~~~~~
Set this option on False, if no needs should be documented inside the generated documentation.

Default: **True**::

    needs_include_needs = False

needs_id_length
~~~~~~~~~~~~~~~
This option defines the length of an automated generated ID (the length of the prefix does not count).

Default: **5**::

    needs_id_length = 3

.. _need_types:

needs_types
~~~~~~~~~~~

The option allows the setup of own need types like bugs, user_stories and more.

By default it is set to::

    needs_types = [dict(directive="req", title="Requirement", prefix="R_", color="#BFD8D2", style="node"),
                   dict(directive="spec", title="Specification", prefix="S_", color="#FEDCD2", style="node"),
                   dict(directive="impl", title="Implementation", prefix="I_", color="#DF744A", style="node"),
                   dict(directive="test", title="Test Case", prefix="T_", color="#DCB239", style="node"),
                   # Kept for backwards compatibility
                   dict(directive="need", title="Need", prefix="N_", color="#9856a5", style="node")
               ]

needs_types must be a list of dictionaries, where each dictionary **must** contain the following items:

* **directive**: Name of the directive. For instance "req", which can be used via `.. req::` in documents
* **title**: Title, which is used as human readable name in lists
* **prefix**: A prefix for generated IDs, to easily identify that an ID belongs to a specific type. Can also be ""
* **color**: A color as hex value. Used in diagrams and some days maybe in other representations as well.
* **style**: A plantuml node type, like node, artifact, frame, storage or database. See `plantuml documentation <http://plantuml.com/deployment-diagram>`_ for more.

.. _needs_template:

needs_template
~~~~~~~~~~~~~~

The layout of needs can be fully customized by using `jinja <http://jinja.pocoo.org/>`_.

If nothing is set, the following default template is used:

.. code-block:: jinja

    {% raw -%}
    .. _{{id}}:

    {% if hide == false -%}
    .. role:: needs_tag
    .. role:: needs_status
    .. role:: needs_type
    .. role:: needs_id
    .. role:: needs_title

    .. rst-class:: need
    .. rst-class:: need_{{type_name}}

    :needs_type:`{{type_name}}`: :needs_title:`{{title}}` :needs_id:`{{id}}`
        {%- if status and  status|upper != "NONE" and not hide_status %}
        | status: :needs_status:`{{status}}`
        {%- endif -%}
        {%- if tags and not hide_tags %}
        | tags: :needs_tag:`{{tags|join("` :needs_tag:`")}}`
        {%- endif %}
        | links incoming: :need_incoming:`{{id}}`
        | links outgoing: :need_outgoing:`{{id}}`

        {{content|indent(4) }}

    {% endif -%}
    {% endraw %}

Available jinja variables are:

* type
* type_name
* type_prefix
* status
* tags
* id
* links
* title
* content
* hide
* hide_tags
* hide_status

.. warning::

   You must add a reference like `.. _{{ '{{id}}' }}:` to the template. Otherwise linking will not work!

needs_diagram_template
~~~~~~~~~~~~~~~~~~~~~~

This option allows to control the content of diagram elements, which get automatically generated by using
`.. needfilter::` and `:layout: diagram.`

This function is based on `plantuml <http://plantuml.com>`_, so that each
`supported style <http://plantuml.com/creole>`_ can be used.

The rendered template is used inside the following plantuml syntax and must care about leaving the final string
valid:

.. code-block:: python

    'node "YOUR_TEMPLATE" as need_id [[need_link]]'

By default the following template is used:

.. code-block:: jinja

    {% raw -%}
    <size:12>{{type_name}}</size>\\n**{{title}}**\\n<size:10>{{id}}</size>
    {% endraw %}

.. _needs_id_required:

needs_id_required
~~~~~~~~~~~~~~~~~

.. versionadded:: 0.1.19

Forces the user to set an ID for each need, which gets defined.

So no ID is autogenerated anymore, if this option is set to True::

    needs_id_required = True

By default this option is set to **False**.

If an ID is missing sphinx throws the exception "NeedsNoIdException" and stops the build.

**Example**::

    # With needs_id_required = True

    .. req:: Working Requirement
       :id: R_001

    .. req:: *Not* working, because :id: is not set.


    # With needs_id_required = False

    .. req:: This works now!

.. _needs_show_link_type:

needs_show_link_type
~~~~~~~~~~~~~~~~~~~~
.. versionadded:: 0.1.27

This option mostly effects the roles :ref:`role_need_outgoing` and :ref:`role_need_incoming` by showing
the *type* beside the ID the linked need.

Can be combined with **needs_show_link_title**.

Activate it by setting it on True in your conf.py::

    needs_show_link_type = True


.. _needs_show_link_title:

needs_show_link_title
~~~~~~~~~~~~~~~~~~~~~
.. versionadded:: 0.1.27

This option mostly effects the roles :ref:`role_need_outgoing` and :ref:`role_need_incoming` by showing
the *title* beside the ID the linked need.

Can be combined with **needs_show_link_type**.

Activate it by setting it on True in your conf.py::

    needs_show_link_title = True

.. _needs_file:

needs_file
~~~~~~~~~~
.. versionadded:: 0.1.30

Defines the location of a json file, which is used by the builder :ref:`needs_builder` as input source.
Default value: *needs.json*.

.. _needs_statuses:

needs_statuses
~~~~~~~~~~~~~~

.. versionadded:: 0.1.41

Defines a set of valid statuses, which are allowed to be used inside documentation.
If a not defined status is detected, an error is thrown and the build stops.
The checks are case sensitive.

Activate it by setting it like this::

    needs_statuses = [
        dict(name="open", description="Nothing done yet"),
        dict(name="in progress", description="Someone is working on it"),
        dict(name="implemented", description="Work is done and implemented"),
    ]

If parameter is not set or set to *False*, no checks will be performed.

Default value: *False*.

.. _needs_tags:

needs_tags
~~~~~~~~~~

.. versionadded:: 0.1.41

Defines a set of valid tags, which are allowed to be used inside documentation.
If a not defined tag is detected, an error is thrown and the build stops.
The checks are case sensitive.

Activate it by setting it like this::

    needs_tags = [
        dict(name="new", description="new needs"),
        dict(name="security", description="tag for security needs"),
    ]

If parameter is not set or set to *False*, no checks will be performed.

Default value: *False*.


.. _needs_css:

needs_css
~~~~~~~~~

.. versionadded:: 0.1.42

Defines the location of a css file, which will be added during documentation build.

If path is relative, sphinx-needs will search for related file in its own css-folder only!
Currently supported css files:

* **blank.css** : css file with empty styles
* **modern.css**: modern styles for a need (default)

Use it like this::

    needs_css = "blank.css"


To provide your own css file, the path must be absolute. Example::

    import os

    conf_py_folder = os.path.dirname(__file__)
    needs_css =  os.path.join(conf_py_folder, "my_styles.css")

See :ref:`styles_css` for available css selectors and more.





